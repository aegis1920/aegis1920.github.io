---
layout  : wiki
title   : 마이크로서비스 도입, 이렇게 한다
summary : 
date    : 2022-10-03 19:17:21 +0900
updated : 2022-10-16 15:22:17 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

책 스터디 간단 정리 내용

### 1장 더도 덜도 아닌 딱 마이크로서비스

- 마이크로서비스는 independent deployability 해야한다.
    - 서비스가 느슨하게 결합 -> 그러려면 서비스 경계를 먼저 찾아야함
    - 경계를 정의하는 방법은 뭘까? -> 매번 고민..
- 데이터베이스 공유는 하지말자.
- 모놀리스
    - 모든 코드를 단일 프로세스 하나로 패키징
    - 멀티모듈 방식으로도 가능
        - 모듈 경계 잘 설정하기
- 잘 정의된 서비스 인터페이스 뒤에 데이터베이스를 숨기면 서비스가 노출 대상의 범위를 제한하고 데이터 표현 방식을 변경할 수 있다
- 구현 결합도
    - 개발자가 직접 컨트롤 가능
- 시간적 결합도. 메시지가 전송되는 시점과 메시지가 처리되는 방식
    - 캐시를 사용하면 나름 해결됨
    - 또는 비동기 전송
- 배포 결합도
    - 전체가 모놀리스면 모든 게 반드시 함께 배포되어야 함
    - 마이크로 서비스로 분해해 배포 범위를 줄여 배포 위험을 낮출 수 있음
    - 범위가 줄어들어서 문제를 찾기도 쉬워짐
- 도메인 결합도
    - 어떤 도메인에서 어떤 데이터를 공유해야 하는지 고민
- 이런 비즈니스 도메인을 중심으로 서비스를 모델링하는 구현 방법이 바로 도메인 주도 설계
    - aggregate는 수명 주기가 있으므로 state machine으로 구현할 수 있다
    - bounded context는 구현 세부사항을 숨김. aggregate가 여러 개
    - 둘 다 잘 정의된 인터페이스로서 응집력의 단위를 제공함
    - 그래서 둘 다 서비스의 경계로 작동할 수 있음

> 마이크로서비스의 목표는 '가능한 한 작은 인터페이스를 유지하는 것'

### 2장 마이그레이션 계획하기

- 작업에 착수하는 시간이라던지, 배포하는 시간이 느릴 수 있다. 
- 도메인에 낮선 경우, 너무 조기에 시스템을 마이크로서비스로 분해하면 높은 비용이 발생할 수 있다
- 서비스 2개도 관리하기 버겁다면 마이크로서비스 10개를 관리하는 일은 더 어려울 것이다
- 모든 사람이 마이크로서비스를 하기 때문에 따라한다는 생각은 끔찍할 뿐이다
- 부차적인 목표를 위해 행해진 작업이 유용할 수도 있으나, 그것이 핵심 목표를 방해하거나 주의를 흩트린다면 이런 목표들은 뒤로 빠져야 마땅하다.
    - 트래픽 증가 처리를 위해 마이크로서비스 도입과 함께 코틀린 언어 도입 시도, 등등...
- 부수적인 이익을 위해 새로운 기술을 혼용하지 마라. 당장 직면한 구체적인 문제를 해결하기 위한 기술을 도입하라.
- 점진적인 마이그레이션을 하라. 분해 과정에서 발생하는 영향을 습득하고 이해하자
- 직도메인 모델의 관계들을 직접 그려보면서 파악해보자
- 의존성이 없는 것부터 차례대로 분해
- 여러 서비스들 중 어떤 서비스가 분해하기 좋을지 우선순위를 매겨보자.
- 다른 조직이 수행한 작업에서 영감을 얻지만, 다른 누군가에게 맞아 떨어진 이론이 자신의 상황에서도 효과가 있다고 가정해서는 안 된다.
- 각 단계를 작게 만들면, 매몰 비용 오류의 함정을 피하기가 좀 더 쉬워진다.

> 일을 시작하기 전 왜 그 일을 해야하는지가 가장 중요하다.
> 기술지향보다 중요한 건 고객 지향
 
### 3장 모놀리스 분할

- 기존 코드베이스를 먼저 이해하고 모듈식 모노리스로 변경하자
    - 때때로 팀들은 기존 코드 수정만으로 충분한 성과를 거두기에 애당초 마이크로 서비스가 필요하지 않다는 사실을 깨닫게 된다
    - 모놀리스에서 코드를 복사하기를 원하지만, 회소한 당장은 모놀리스 자체에서 이 기능을 제거하고 싶지는 않다는 점이다. 왜일까? 일정 기간 동안 모놀리스의 기능을 그대로 두면 롤백 포인트를 확보하거나, 혹은 두 가지 구현을 병행 실행하는 기회를 얻을 수 있다. 또한 이후에 마이그레이션이 성공적으로 완료되면, 모놀리스에서 기능을 제거할 수 있다.
- 교살자 무화가 애플리케이션 패턴
    - 새로운 구현이 준비되면, 모놀리스에 대한 호출을 신규 마이크로서비스에 대한 호출로 전환하게끔 라우팅할 수 있어야 한다. (프록시 사용)
    - HTTP를 사용하면 리디렉션 관리르 위한 옵션이 다양함 (nginx 등등...)
    - 사용중인 프로토콜의 마이그레이션을 원한다면, 기존 프로토콜과 새 프로토콜을 모두 지원하는 서비스를 사용해 매핑을 서비스 자체에 적용하는 방식이 훨씬 더 낫다.
        - 기존 프로토콜이 SOAP, 새로운 프로토콜이 gRPC라면 둘 다 받을 수 있도록 만든 후, SOAP -> gRPC 매퍼를 만들면 된다.
    - 메시지큐를 사용할 경우, 동일한 대기열에 대해 더 많은 유형의 컨슈머가 있고 필터링 규칙이 복잡해질수록 문제가 발생할 수 있는 가능성도 커진다.
- UI 컴포지션 패턴
    - UI를 통해 마이크로서비스 아키텍쳐에서 제공하는 기능을 결합
- 추상화에 의한 분기 패턴
    - 대체할 기능을 위한 추상화 생성
    - 새로운 추상화를 사용하기 위해 기존 기능을 이용하는 클라이언트를 변경
    - 기능을 대체에 추상화를 새롭게 구현
    - 추상화를 전환
    - 추상화를 정리하고 기존 구현 제거
- 병행 실행 패턴
    - 기존 시스템과 새로운 시스템으로 병행 실행시킨 후, 결과를 비교하는 방법도 있다 (변경되는 기능의 위험성이 높다고 간주되는 경우 사용)
- 협업자 데코레이터 패턴
    - 프록시를 사용해 호출을 가로채어 기존 모놀리스에 변경을 가하지 않고 결과를 적용시킬 수 있다. (기존 모놀리스의 결과 응답을 프록시에서 캐치해 다른 마이크로서비스에 보냄)
    - 해당 마이크로서비스가 다시 기존 모놀리스를 호출하지 않도록 주의 (순환 종속성을 일으킬 수 있음)
- 변경 데이터 캡처 패턴
    - DB에서 변경된 데이터를 캡쳐해 마이크로서비스를 호출할수도 있다 (프로그램을 이해하기 어려워지고 DB 작업에 종속되므로 가급적 하지 말기)
    - DB 트리거를 사용해 호출
    - 트랜잭션 commit 시 트랜잭션 로그를 통해 호출 가능
    - 해당 패턴은 데이터를 복제할 필요가 있을 경우에만 사용하자

> 서버 앞에 프록시가 있는 게 여러모로 결합도를 낮추는데 도움되는듯
> 기존 기능은 그대로 둔 채 신규 기능 개발하고 점진적으로 마이그레이션




