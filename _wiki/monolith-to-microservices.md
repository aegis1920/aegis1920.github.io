---
layout  : wiki
title   : 마이크로서비스 도입, 이렇게 한다
summary : 
date    : 2022-10-03 19:17:21 +0900
updated : 2022-10-23 18:14:57 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

책 스터디 간단 정리 내용

### 1장 더도 덜도 아닌 딱 마이크로서비스

- 마이크로서비스는 independent deployability 해야한다.
    - 서비스가 느슨하게 결합 -> 그러려면 서비스 경계를 먼저 찾아야함
    - 경계를 정의하는 방법은 뭘까? -> 매번 고민..
- 데이터베이스 공유는 하지말자.
- 모놀리스
    - 모든 코드를 단일 프로세스 하나로 패키징
    - 멀티모듈 방식으로도 가능
        - 모듈 경계 잘 설정하기
- 잘 정의된 서비스 인터페이스 뒤에 데이터베이스를 숨기면 서비스가 노출 대상의 범위를 제한하고 데이터 표현 방식을 변경할 수 있다
- 구현 결합도
    - 개발자가 직접 컨트롤 가능
- 시간적 결합도. 메시지가 전송되는 시점과 메시지가 처리되는 방식
    - 캐시를 사용하면 나름 해결됨
    - 또는 비동기 전송
- 배포 결합도
    - 전체가 모놀리스면 모든 게 반드시 함께 배포되어야 함
    - 마이크로 서비스로 분해해 배포 범위를 줄여 배포 위험을 낮출 수 있음
    - 범위가 줄어들어서 문제를 찾기도 쉬워짐
- 도메인 결합도
    - 어떤 도메인에서 어떤 데이터를 공유해야 하는지 고민
- 이런 비즈니스 도메인을 중심으로 서비스를 모델링하는 구현 방법이 바로 도메인 주도 설계
    - aggregate는 수명 주기가 있으므로 state machine으로 구현할 수 있다
    - bounded context는 구현 세부사항을 숨김. aggregate가 여러 개
    - 둘 다 잘 정의된 인터페이스로서 응집력의 단위를 제공함
    - 그래서 둘 다 서비스의 경계로 작동할 수 있음

> 마이크로서비스의 목표는 '가능한 한 작은 인터페이스를 유지하는 것'

### 2장 마이그레이션 계획하기

- 작업에 착수하는 시간이라던지, 배포하는 시간이 느릴 수 있다. 
- 도메인에 낮선 경우, 너무 조기에 시스템을 마이크로서비스로 분해하면 높은 비용이 발생할 수 있다
- 서비스 2개도 관리하기 버겁다면 마이크로서비스 10개를 관리하는 일은 더 어려울 것이다
- 모든 사람이 마이크로서비스를 하기 때문에 따라한다는 생각은 끔찍할 뿐이다
- 부차적인 목표를 위해 행해진 작업이 유용할 수도 있으나, 그것이 핵심 목표를 방해하거나 주의를 흩트린다면 이런 목표들은 뒤로 빠져야 마땅하다.
    - 트래픽 증가 처리를 위해 마이크로서비스 도입과 함께 코틀린 언어 도입 시도, 등등...
- 부수적인 이익을 위해 새로운 기술을 혼용하지 마라. 당장 직면한 구체적인 문제를 해결하기 위한 기술을 도입하라.
- 점진적인 마이그레이션을 하라. 분해 과정에서 발생하는 영향을 습득하고 이해하자
- 직도메인 모델의 관계들을 직접 그려보면서 파악해보자
- 의존성이 없는 것부터 차례대로 분해
- 여러 서비스들 중 어떤 서비스가 분해하기 좋을지 우선순위를 매겨보자.
- 다른 조직이 수행한 작업에서 영감을 얻지만, 다른 누군가에게 맞아 떨어진 이론이 자신의 상황에서도 효과가 있다고 가정해서는 안 된다.
- 각 단계를 작게 만들면, 매몰 비용 오류의 함정을 피하기가 좀 더 쉬워진다.

> 일을 시작하기 전 왜 그 일을 해야하는지가 가장 중요하다.
> 기술지향보다 중요한 건 고객 지향
 
### 3장 모놀리스 분할

- 기존 코드베이스를 먼저 이해하고 모듈식 모노리스로 변경하자
    - 때때로 팀들은 기존 코드 수정만으로 충분한 성과를 거두기에 애당초 마이크로 서비스가 필요하지 않다는 사실을 깨닫게 된다
    - 모놀리스에서 코드를 복사하기를 원하지만, 회소한 당장은 모놀리스 자체에서 이 기능을 제거하고 싶지는 않다는 점이다. 왜일까? 일정 기간 동안 모놀리스의 기능을 그대로 두면 롤백 포인트를 확보하거나, 혹은 두 가지 구현을 병행 실행하는 기회를 얻을 수 있다. 또한 이후에 마이그레이션이 성공적으로 완료되면, 모놀리스에서 기능을 제거할 수 있다.
- 교살자 무화가 애플리케이션 패턴
    - 새로운 구현이 준비되면, 모놀리스에 대한 호출을 신규 마이크로서비스에 대한 호출로 전환하게끔 라우팅할 수 있어야 한다. (프록시 사용)
    - HTTP를 사용하면 리디렉션 관리르 위한 옵션이 다양함 (nginx 등등...)
    - 사용중인 프로토콜의 마이그레이션을 원한다면, 기존 프로토콜과 새 프로토콜을 모두 지원하는 서비스를 사용해 매핑을 서비스 자체에 적용하는 방식이 훨씬 더 낫다.
        - 기존 프로토콜이 SOAP, 새로운 프로토콜이 gRPC라면 둘 다 받을 수 있도록 만든 후, SOAP -> gRPC 매퍼를 만들면 된다.
    - 메시지큐를 사용할 경우, 동일한 대기열에 대해 더 많은 유형의 컨슈머가 있고 필터링 규칙이 복잡해질수록 문제가 발생할 수 있는 가능성도 커진다.
- UI 컴포지션 패턴
    - UI를 통해 마이크로서비스 아키텍쳐에서 제공하는 기능을 결합
- 추상화에 의한 분기 패턴
    - 대체할 기능을 위한 추상화 생성
    - 새로운 추상화를 사용하기 위해 기존 기능을 이용하는 클라이언트를 변경
    - 기능을 대체에 추상화를 새롭게 구현
    - 추상화를 전환
    - 추상화를 정리하고 기존 구현 제거
- 병행 실행 패턴
    - 기존 시스템과 새로운 시스템으로 병행 실행시킨 후, 결과를 비교하는 방법도 있다 (변경되는 기능의 위험성이 높다고 간주되는 경우 사용)
- 협업자 데코레이터 패턴
    - 프록시를 사용해 호출을 가로채어 기존 모놀리스에 변경을 가하지 않고 결과를 적용시킬 수 있다. (기존 모놀리스의 결과 응답을 프록시에서 캐치해 다른 마이크로서비스에 보냄)
    - 해당 마이크로서비스가 다시 기존 모놀리스를 호출하지 않도록 주의 (순환 종속성을 일으킬 수 있음)
- 변경 데이터 캡처 패턴
    - DB에서 변경된 데이터를 캡쳐해 마이크로서비스를 호출할수도 있다 (프로그램을 이해하기 어려워지고 DB 작업에 종속되므로 가급적 하지 말기)
    - DB 트리거를 사용해 호출
    - 트랜잭션 commit 시 트랜잭션 로그를 통해 호출 가능
    - 해당 패턴은 데이터를 복제할 필요가 있을 경우에만 사용하자

> 서버 앞에 프록시가 있는 게 여러모로 결합도를 낮추는데 도움되는듯
> 기존 기능은 그대로 둔 채 신규 기능 개발하고 점진적으로 마이그레이션

### 4장 데이터베이스 분해

1. 공유 데이터베이스 패턴
    1. 말 그대로 데이터베이스가 공유되고 있는 것
    2. 그러나 각 마이크로서비스가 자체적인 데이터를 소유할 수 있도록 데이터베이스를 분리하는 방식이 거의 항상 선호된다.
    3. 데이터베이스 엔진의 단일 인스턴스는 여러 스키마를 제공할 수 있으며, 각 스키마는 논리적으로 데이터를 격리한다
3. 데이터베이스 뷰 패턴
    1. 외부 시스템은 뷰로부터 데이터를 읽도록 전환되어 데이터를 은닉하고 스키마에서 직접 읽을 필요가 없어 성능을 높일 수 있다. 그러나 사전에 계산된 뷰가 어떻게 업데이트되는지와 관련해 어려움이 생기며, 이는 뷰에서 stale 데이터 집합을 읽을 수도 있다는 의미다.
    2. 더불어 뷰를 지원하지 않는 DB엔진이 있고 기반 스키마와 뷰가 동일 데이터베이스 엔진에 존재해야 하는 등의 여러 제약이 있을 가능성이 높다. 이는 물리적인 배포 결합도를 증가시켜 잠재적인 단일 장애 지점을 만들 수 있다.
    3. 기반 스키마를 변경하면 뷰도 업데이트해야할 수 있다. 또한 뷰의 소유권도 확인해야 한다
    4. 그러면 언제 뷰를 써야할까? 기존 모놀리스 스키마를 분해하는 방식이 실용적이지 않다고 여겨지는 상황일 때 뷰를 사용할 수 있따. 그냥 모놀리스 스키마를 사용하는 것보단 나으니까?
4. 데이터베이스 래핑 서비스 패턴
    5. 앱에서 데이터베이스에 직접 접근하는 게 아니라 래퍼 역할을 하는 서비스를 하나 만들어서 DB 접근이 필요하면 그 서비스를 호출하도록 만든다.
    6. 이러면 공유할 대상을 제어할 수 있다.
    7. 테스트 목적을 위한 스텁을 직접 추가할 수도 있고 기존 테이블 구조에 매핑할 수 있는 뷰를 표현하는 과정에 제약이 없다.
5. DaaS 인터페이스 패턴
    1. 읽기 전용 외부 공개 데이터베이스를 만들고 기반 데이터베이스가 변경될 때 그 외부 데이터베이스를 채우는 방식. 외부 데이터베이스에 채워줄 때 매핑 엔진이 필요하다.
        1. 매핑 엔진은 기반 데이터베이스와 외부 데이터베이스의 일관성을 유지하기 위함
    2. 즉, 읽기 전용이 필요한 클라이언트가 있을 경우 유용하다
    3. 외부에 공개된 데이터베이스에서 읽는 클라이언트는 이미 stale한 데이터를 보고있을 수도 있다. 그래서 이 DB가 마지막으로 업데이트된 시기에 대한 정보를 외부에 공개해서 어느정도 인지를 시켜줘야될 수도 있다
6. 집계를 외부에 공개하는 모놀리스 패턴
    1. 단순히 모놀리스 자체에서 API를 제공하는 걸 말하는 것 같다.
    2. 서비스를 추출할 때, 필요한 데이터에 접근하기 위해 새로운 서비스가 거꾸로 모놀리스를 호출하는 경우는 모놀리스의 데이터베이스에 직접 접근하는 경우보다 조금 더 작업이 필요할 가능성이 높지만 장기적으로는 훨씬 더 좋은 방식이다.
7. 데이터 소유권 변경 패턴
    1. 기존 모놀리스에서 송장 테이블에 접근하던 것을 없애고 송장 서비스에 API를 호출해서 송장 데이터를 얻을 수 있도록 한다.
    2. 만약 읽기 접근만 필요하다면 모놀리스에서 송장 테이블에 접근이 필요할 때 뷰를 활용할 수 있다.
8. 애플리케이션에서 데이터 동기화 패턴
    1. 새 버전의 애플리케이션이 배포되어 두 DB에 모든 데이터를 기록한다. (읽기 쓰기 모두)
        1. 읽기는 기존 DB만, 쓰기는 기존 DB와 새로운 DB에 한다
        2. 그리고 읽기를 새로운 DB에만 하도록 옮긴다
    2. 두 DB가 항상 동기화되어있어 롤백 시나리오에 아주 유리하다.
9. 예광탄 기록 패턴
    1. 작은 데이터 집합을 기준으로 모놀리스에서 쓰기만 하고 새로운 서비스에서 읽고 쓰도록 한다.
    2. API 콜을 두 번(기존 모놀리스, 분리된 마이크로서비스)씩 해서 양쪽에 쏠 수 있으나 둘 중 한 곳에서는 실패할 경우, 오류 조건을 처리해야해서 두 시스템간 불일치가 발생할 수 있다.

> 뷰를 쓰는 이유를 잘 모르겠다.  정보를 은닉할 수 있다는 장점 말고는 없어보인다. 마이그레이션할 때도 DB에 직접 접근하지 말고 API Call로 대체하자. 기존 DB와 새로운 DB에 함께 쓰고, 읽기를 새로운 DB로 옮기자.
