---
layout  : wiki
title   : 알고리즘을 공부하기 전에 알아야 할 것들
summary : 
date    : 2019-08-24 00:03:04 +0900
updated : 2019-09-07 09:34:14 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

## 풀기 전에 생각해봐야될 것들

- 알고리즘에서 가장 중요한 건 주어진 입력으로 답을 내기까지의 시간
* 시간복잡도(N의 제한, 입력의 크기)를 먼저 생각해본다. 
    * 반복을 최대한 줄여야 한다.
    * for문을 유심히 보자
* 1억 연산에 1초가 걸린다.
* 원리나 증명도 중요하지만 응용하는 것이 더 중요하다. 원리을 알려고 하기보다 써보면서 익히자.
* 개발은 모든 것을 스스로 해결하는 것을 요구하지 않는다.
* 코딩 테스트에서는 문제를 잘 읽고 조건을 제대로 파악한 후 설계부터 해야된다.
* 설계가 다 됐다고 생각했을 때 다시 한 번 생각하자.
* 최악의 케이스를 생각하자.
* 시간이 오래걸릴 것 같은 함수에 전역변수로 COUNT++을 해놓고 나중에 COUNT를 비교해서 어떤 조건이 있을 때와 없을 때 COUNT변수로 어떤 것이 시간이 더 빠른지(더 적게 호출되는지) 알 수 있다.

## 연산의 속도

`i += 1` 보다 `i++`이 더 빠르다
`i *= 2` 보다 `i<<1`이 더 빠르다
`i /= 2` 보다 `i>>1`이 더 빠르다

n이 계속 커지더라도 이 알고리즘을 써도 되는지 생각해보자.

시간복잡도, 공간복잡도가 있지만 공간복잡도가 부족한 경우는 거의 없다. 

코드가 150줄 이상 나가면 어렵게 생각하고 있다는 것을 말해준다.

일단 생각나는대로 풀어보자. 그 후에 리펙토링을 하자.

O(nlogn)정도면 괜찮다.

CPU연산을 1억번 연산당 1초정도가 걸린다. 자바의 경우, 2초 이내에 끝내야 좋은 알고리즘이다.

시뮬레이션 문제는 하라는대로 하면 된다.

웬만하면 컬렉션을 쓰자. 최적화되어있는 코드니까.

쉬우면 쉬운대로 금방 풀 수 있어야 한다.

어떤 문제를 접했을 때 정렬을 먼저 하고 하면 어떻게 될까 생각을 먼저. primitive는 상관없지만 reference는 안에서 어떤 데이터를 기준으로
삼을지 생각해야 된다.

일단 완전탐색으로 해보고 만약 시간이 넘으면 다른 거로 풀어보자.

## 시간복잡도를 표기하기 위한 표현법

### 빅오표기법
- 계산 시간이 가장 최악일 때를 표현하는 방법
- 가장 큰 영향을 주는 n같은 부분은 남기고 상수의 표현식들은 삭제한다.


